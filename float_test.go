// Code generated by float_test.go.tmpl. DO NOT EDIT.

package float

import (
	"fmt"
	"math/rand"
	"testing"

	"./avx"
	"golang.org/x/sys/cpu"

	"gonum.org/v1/gonum/blas/blas32"

	"gonum.org/v1/gonum/blas/blas64"
)

func TestCPU(t *testing.T) {
	fmt.Println("cpu.X86.HasAVX2", cpu.X86.HasAVX2)
	fmt.Println("cpu.X86.HasFMA", cpu.X86.HasFMA)
	// Output:
}
func blas32Dot(x, y []float32) float32 {
	return blas32.Dot(len(x), blas32.Vector{1, x}, blas32.Vector{1, y})
}
func blas64Dot(x, y []float64) float64 {
	return blas64.Dot(blas64.Vector{len(x), 1, x}, blas64.Vector{len(y), 1, y})
}

func ExampleSign32() {
	fmt.Println(f32.Sign(-.1), f32.Sign(0), f32.Sign(.1))
	// Output:
	//-1 1 1
}

func ExampleSort32() {
	a := []float32{4, 3, 2}
	F32s(a).Sort()
	fmt.Println(a)
	// Output:
	//[2 3 4]
}

func ExampleSearch32() {
	fmt.Println(F32s([]float32{2, 3, 4}).Search(3))
	// Output:
	// 1
}
func ExampleArgSort32() {
	a := []float32{4, 3, 2}
	fmt.Println(f32.ArgSort(a))
	// Output:
	//[2 1 0]
}

func ExampleMedian32() {
	fmt.Println(f32.Median([]float32{5, 2, 1}))
	// Output:
	// 2
}

func random32(n int) []float32 {
	x := make([]float32, n)
	for i := range x {
		x[i] = rand.Float32()
	}
	return x
}

func ExampleScale32() {
	x := random32(123)
	scale := rand.Float32()
	expected := make([]float32, 123)
	actual := make([]float32, 123)
	for i := range x {
		expected[i] = x[i] * scale
	}
	for _, o := range []struct {
		Name string
		Func func(scale float32, x []float32)
	}{
		{"Scale", f32.Scale},
	} {
		copy(actual, x)
		o.Func(scale, actual)
		for i := range x {
			if f32.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}

	// Output:
}

func ExampleAdd32() {
	x := random32(123)
	y := random32(123)
	expected := make([]float32, 123)
	actual := make([]float32, 123)
	for i := range x {
		expected[i] = x[i] + y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(x, y []float32)
	}{
		{"Add", f32.Add},
	} {
		copy(actual, x)
		o.Func(actual, y)
		for i := range x {
			if f32.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}

	// Output:
}

func ExampleMul32() {
	x := random32(123)
	y := random32(123)
	expected := make([]float32, 123)
	actual := make([]float32, 123)
	for i := range x {
		expected[i] = x[i] * y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(x, y []float32)
	}{
		{"Add", f32.Mul},
	} {
		copy(actual, x)
		o.Func(actual, y)
		for i := range x {
			if f32.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}

	// Output:
}

func ExampleAddTo32() {
	x := random32(123)
	y := random32(123)
	expected := make([]float32, 123)
	actual := make([]float32, 123)
	for i := range x {
		expected[i] = x[i] + y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(dst, x, y []float32)
	}{
		{"vanilla", f32.vanillaAddTo},
		{"unrolled", f32.unrolledAddTo},
		{"avx", f32.AddTo},
	} {

		o.Func(actual, x, y)
		for i := range x {
			if f32.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}

	// Output:
}

func ExampleSubTo32() {
	x := random32(123)
	y := random32(123)
	expected := make([]float32, 123)
	actual := make([]float32, 123)
	for i := range x {
		expected[i] = x[i] - y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(dst, x, y []float32)
	}{
		{"vanilla", f32.vanillaSubTo},
		{"unrolled", f32.unrolledSubTo},
		{"avx", f32.SubTo},
	} {

		o.Func(actual, x, y)
		for i := range x {
			if f32.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}
	// Output:
}

func ExampleMulTo32() {
	x := random32(123)
	y := random32(123)
	expected := make([]float32, 123)
	actual := make([]float32, 123)
	for i := range x {
		expected[i] = x[i] * y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(dst, x, y []float32)
	}{
		{"vanilla", f32.vanillaMulTo},
		{"unrolled", f32.unrolledMulTo},
		{"avx", f32.MulTo},
	} {

		o.Func(actual, x, y)
		for i := range x {
			if f32.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}
	// Output:
}

func ExampleScaleTo32() {
	x := random32(123)
	scale := rand.Float32()
	expected := make([]float32, 123)
	actual := make([]float32, 123)
	for i := range x {
		expected[i] = x[i] * scale
	}
	for _, o := range []struct {
		Name string
		Func func(dst, x []float32, scale float32)
	}{
		{"vanilla", f32.vanillaScaleTo},
		{"unrolled", f32.unrolledScaleTo},
		{"avx", f32.ScaleTo},
	} {

		o.Func(actual, x, scale)
		for i := range x {
			if f32.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}
	// Output:
}

func ExampleSum32() {
	x := random32(123)
	var expected, actual float32
	for i := range x {
		expected += x[i]
	}
	for _, o := range []struct {
		Name string
		Func func(x []float32) float32
	}{
		{"vanilla", f32.vanillaSum},
		{"unrolled", f32.unrolledSum},
		{"avx", f32.Sum},
	} {

		actual = o.Func(x)
		if f32.Abs(actual-expected) > .001 {
			fmt.Printf("%s Expected %g actual %g\n", o.Name, expected, actual)
		}

	}
	// Output:
}

func ExampleDot32() {

	x, y := random32(123), random32(123)
	var expected, actual float32
	for i := range x {
		expected += x[i] * y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(x, y []float32) float32
	}{
		{"vanilla", f32.vanillaDot},
		{"unrolled", f32.unrolledDot},
		{"avx", f32.Dot},
	} {

		actual = o.Func(x, y)
		if f32.Abs(actual-expected) > .001 {
			fmt.Printf("%s Expected %g actual %g\n", o.Name, expected, actual)
		}

	}
	// Output:
}

func ExampleMean32() {
	fmt.Println(f32.Mean([]float32{6, 2, 1}))
	// Output:
	// 3
}
func ExampleMaxIdx32() {
	fmt.Println(f32.MaxIdx([]float32{6, 2, 1}))
	// Output:
	// 0
}
func ExampleMinIdx32() {
	fmt.Println(f32.MinIdx([]float32{6, 2, 1}))
	// Output:
	// 2
}
func ExampleMax32() {
	fmt.Println(f32.Max([]float32{6, 2, 1}))
	// Output:
	// 6
}
func ExampleMin32() {
	fmt.Println(f32.Min([]float32{6, 2, 1}))
	// Output:
	// 1
}

func ExampleAlloc32() {
	var a, b F32s
	f32.Alloc(8760, &a, &b)
	if a == nil || b == nil || len(a) != len(b) {
		fmt.Println("unexpected")
	}
	//Output:
}
func ExampleEqualWithinAbs32() {
	var expected, actual bool
	expected, actual = true, f32.EqualWithinAbs(1, 1.1, .101)
	if expected != actual {
		fmt.Printf("expected %v actual %v\n", expected, actual)
	}
	expected, actual = false, f32.EqualWithinAbs(1, 1.1, .099)
	if expected != actual {
		fmt.Printf("expected %v actual %v\n", expected, actual)
	}
	// Output:
}
func BenchmarkSum32(b *testing.B) {
	a := make([]float32, 8760)

	for _, f := range []struct {
		Name string
		Func func([]float32) float32
	}{
		{"vanillaSum", f32.vanillaSum},
		{"unrolledSum", f32.unrolledSum},
		{"Sum", f32.Sum},
	} {
		b.Run(f.Name, func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				f.Func(a)
			}
		})
	}
}

func BenchmarkDot32(b *testing.B) {
	a := make([]float32, 81818)
	for _, l := range []int{818, 8181, 81818} {
		for _, f := range []struct {
			Name string
			Func func(x, y []float32) float32
		}{
			{fmt.Sprintf("vanillaDot/%d", l), f32.vanillaDot},
			{fmt.Sprintf("unrolledDot/%d", l), f32.unrolledDot},
			{fmt.Sprintf("blas32.Dot/%d", l), blas32Dot},
			{fmt.Sprintf("avx32.Dot/%d", l), (avx.F32{}).Dot},
			{fmt.Sprintf("asm_avx32.Dot/%d", l), avxFloat32Dot},
		} {
			b.Run(f.Name, func(b *testing.B) {
				for i := 0; i < b.N; i++ {
					f.Func(a[:l], a[:l])
				}
			})
		}
	}
}

func BenchmarkAddTo32(b *testing.B) {
	a := make([]float32, 81818)
	for _, l := range []int{818, 8181, 81818} {
		for _, f := range []struct {
			Name string
			Func func(dst, x, y []float32)
		}{
			{fmt.Sprintf("vanillaAddTo/%d", l), f32.vanillaAddTo},
			{fmt.Sprintf("unrolledAddTo/%d", l), f32.unrolledAddTo},
			{fmt.Sprintf("avx32.AddTo/%d", l), (avx.F32{}).AddTo},
			//{fmt.Sprintf("asm_avx32.AddTo/%d",l), avxFloat32AddTo},
		} {
			b.Run(f.Name, func(b *testing.B) {
				for i := 0; i < b.N; i++ {
					f.Func(a[:l], a[:l], a[:l])
				}
			})
		}
	}
}

func ExampleSign64() {
	fmt.Println(f64.Sign(-.1), f64.Sign(0), f64.Sign(.1))
	// Output:
	//-1 1 1
}

func ExampleSort64() {
	a := []float64{4, 3, 2}
	F64s(a).Sort()
	fmt.Println(a)
	// Output:
	//[2 3 4]
}

func ExampleSearch64() {
	fmt.Println(F64s([]float64{2, 3, 4}).Search(3))
	// Output:
	// 1
}
func ExampleArgSort64() {
	a := []float64{4, 3, 2}
	fmt.Println(f64.ArgSort(a))
	// Output:
	//[2 1 0]
}

func ExampleMedian64() {
	fmt.Println(f64.Median([]float64{5, 2, 1}))
	// Output:
	// 2
}

func random64(n int) []float64 {
	x := make([]float64, n)
	for i := range x {
		x[i] = rand.Float64()
	}
	return x
}

func ExampleScale64() {
	x := random64(123)
	scale := rand.Float64()
	expected := make([]float64, 123)
	actual := make([]float64, 123)
	for i := range x {
		expected[i] = x[i] * scale
	}
	for _, o := range []struct {
		Name string
		Func func(scale float64, x []float64)
	}{
		{"Scale", f64.Scale},
	} {
		copy(actual, x)
		o.Func(scale, actual)
		for i := range x {
			if f64.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}

	// Output:
}

func ExampleAdd64() {
	x := random64(123)
	y := random64(123)
	expected := make([]float64, 123)
	actual := make([]float64, 123)
	for i := range x {
		expected[i] = x[i] + y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(x, y []float64)
	}{
		{"Add", f64.Add},
	} {
		copy(actual, x)
		o.Func(actual, y)
		for i := range x {
			if f64.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}

	// Output:
}

func ExampleMul64() {
	x := random64(123)
	y := random64(123)
	expected := make([]float64, 123)
	actual := make([]float64, 123)
	for i := range x {
		expected[i] = x[i] * y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(x, y []float64)
	}{
		{"Add", f64.Mul},
	} {
		copy(actual, x)
		o.Func(actual, y)
		for i := range x {
			if f64.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}

	// Output:
}

func ExampleAddTo64() {
	x := random64(123)
	y := random64(123)
	expected := make([]float64, 123)
	actual := make([]float64, 123)
	for i := range x {
		expected[i] = x[i] + y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(dst, x, y []float64)
	}{
		{"vanilla", f64.vanillaAddTo},
		{"unrolled", f64.unrolledAddTo},
		{"avx", f64.AddTo},
	} {

		o.Func(actual, x, y)
		for i := range x {
			if f64.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}

	// Output:
}

func ExampleSubTo64() {
	x := random64(123)
	y := random64(123)
	expected := make([]float64, 123)
	actual := make([]float64, 123)
	for i := range x {
		expected[i] = x[i] - y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(dst, x, y []float64)
	}{
		{"vanilla", f64.vanillaSubTo},
		{"unrolled", f64.unrolledSubTo},
		{"avx", f64.SubTo},
	} {

		o.Func(actual, x, y)
		for i := range x {
			if f64.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}
	// Output:
}

func ExampleMulTo64() {
	x := random64(123)
	y := random64(123)
	expected := make([]float64, 123)
	actual := make([]float64, 123)
	for i := range x {
		expected[i] = x[i] * y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(dst, x, y []float64)
	}{
		{"vanilla", f64.vanillaMulTo},
		{"unrolled", f64.unrolledMulTo},
		{"avx", f64.MulTo},
	} {

		o.Func(actual, x, y)
		for i := range x {
			if f64.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}
	// Output:
}

func ExampleScaleTo64() {
	x := random64(123)
	scale := rand.Float64()
	expected := make([]float64, 123)
	actual := make([]float64, 123)
	for i := range x {
		expected[i] = x[i] * scale
	}
	for _, o := range []struct {
		Name string
		Func func(dst, x []float64, scale float64)
	}{
		{"vanilla", f64.vanillaScaleTo},
		{"unrolled", f64.unrolledScaleTo},
		{"avx", f64.ScaleTo},
	} {

		o.Func(actual, x, scale)
		for i := range x {
			if f64.Abs(actual[i]-expected[i]) > .001 {
				fmt.Printf("%s Expected[%d] %g actual %g\n", o.Name, i, expected[i], actual[i])
			}
		}
	}
	// Output:
}

func ExampleSum64() {
	x := random64(123)
	var expected, actual float64
	for i := range x {
		expected += x[i]
	}
	for _, o := range []struct {
		Name string
		Func func(x []float64) float64
	}{
		{"vanilla", f64.vanillaSum},
		{"unrolled", f64.unrolledSum},
		{"avx", f64.Sum},
	} {

		actual = o.Func(x)
		if f64.Abs(actual-expected) > .001 {
			fmt.Printf("%s Expected %g actual %g\n", o.Name, expected, actual)
		}

	}
	// Output:
}

func ExampleDot64() {

	x, y := random64(123), random64(123)
	var expected, actual float64
	for i := range x {
		expected += x[i] * y[i]
	}
	for _, o := range []struct {
		Name string
		Func func(x, y []float64) float64
	}{
		{"vanilla", f64.vanillaDot},
		{"unrolled", f64.unrolledDot},
		{"avx", f64.Dot},
	} {

		actual = o.Func(x, y)
		if f64.Abs(actual-expected) > .001 {
			fmt.Printf("%s Expected %g actual %g\n", o.Name, expected, actual)
		}

	}
	// Output:
}

func ExampleMean64() {
	fmt.Println(f64.Mean([]float64{6, 2, 1}))
	// Output:
	// 3
}
func ExampleMaxIdx64() {
	fmt.Println(f64.MaxIdx([]float64{6, 2, 1}))
	// Output:
	// 0
}
func ExampleMinIdx64() {
	fmt.Println(f64.MinIdx([]float64{6, 2, 1}))
	// Output:
	// 2
}
func ExampleMax64() {
	fmt.Println(f64.Max([]float64{6, 2, 1}))
	// Output:
	// 6
}
func ExampleMin64() {
	fmt.Println(f64.Min([]float64{6, 2, 1}))
	// Output:
	// 1
}

func ExampleAlloc64() {
	var a, b F64s
	f64.Alloc(8760, &a, &b)
	if a == nil || b == nil || len(a) != len(b) {
		fmt.Println("unexpected")
	}
	//Output:
}
func ExampleEqualWithinAbs64() {
	var expected, actual bool
	expected, actual = true, f64.EqualWithinAbs(1, 1.1, .101)
	if expected != actual {
		fmt.Printf("expected %v actual %v\n", expected, actual)
	}
	expected, actual = false, f64.EqualWithinAbs(1, 1.1, .099)
	if expected != actual {
		fmt.Printf("expected %v actual %v\n", expected, actual)
	}
	// Output:
}
func BenchmarkSum64(b *testing.B) {
	a := make([]float64, 8760)

	for _, f := range []struct {
		Name string
		Func func([]float64) float64
	}{
		{"vanillaSum", f64.vanillaSum},
		{"unrolledSum", f64.unrolledSum},
		{"Sum", f64.Sum},
	} {
		b.Run(f.Name, func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				f.Func(a)
			}
		})
	}
}

func BenchmarkDot64(b *testing.B) {
	a := make([]float64, 81818)
	for _, l := range []int{818, 8181, 81818} {
		for _, f := range []struct {
			Name string
			Func func(x, y []float64) float64
		}{
			{fmt.Sprintf("vanillaDot/%d", l), f64.vanillaDot},
			{fmt.Sprintf("unrolledDot/%d", l), f64.unrolledDot},
			{fmt.Sprintf("blas64.Dot/%d", l), blas64Dot},
			{fmt.Sprintf("avx64.Dot/%d", l), (avx.F64{}).Dot},
			{fmt.Sprintf("asm_avx64.Dot/%d", l), avxFloat64Dot},
		} {
			b.Run(f.Name, func(b *testing.B) {
				for i := 0; i < b.N; i++ {
					f.Func(a[:l], a[:l])
				}
			})
		}
	}
}

func BenchmarkAddTo64(b *testing.B) {
	a := make([]float64, 81818)
	for _, l := range []int{818, 8181, 81818} {
		for _, f := range []struct {
			Name string
			Func func(dst, x, y []float64)
		}{
			{fmt.Sprintf("vanillaAddTo/%d", l), f64.vanillaAddTo},
			{fmt.Sprintf("unrolledAddTo/%d", l), f64.unrolledAddTo},
			{fmt.Sprintf("avx64.AddTo/%d", l), (avx.F64{}).AddTo},
			//{fmt.Sprintf("asm_avx64.AddTo/%d",l), avxFloat64AddTo},
		} {
			b.Run(f.Name, func(b *testing.B) {
				for i := 0; i < b.N; i++ {
					f.Func(a[:l], a[:l], a[:l])
				}
			})
		}
	}
}
