// Code generated by float.gen.go.tmpl. DO NOT EDIT.

package float

import (
	"fmt"
	"sort"

	math32 "github.com/chewxy/math32"

	math64 "math"
)

type F32 float32
type F32s []float32

var f32 F32

func (F32) NaN() float32 { return math32.NaN() }

func (F32) IsNaN(x float32) bool { return math32.IsNaN(x) }

// Len (sort.Interface)
func (a F32s) Len() int { return len(a) }

// Less  (sort.Interface)
func (a F32s) Less(i, j int) bool { return a[i] < a[j] }

// Swap  (sort.Interface)
func (a F32s) Swap(i, j int) { a[i], a[j] = a[j], a[i] }

// Sort  (sort.Interface)
func (a F32s) Sort() {
	sort.Sort(F32s(a))
}

// Search  (sort.Interface)
func (a F32s) Search(x float32) int {
	return sort.Search(len(a), func(i int) bool { return a[i] >= x })
}

// ArgSort ...
func (F32) ArgSort(a []float32) []int {
	ind := make([]int, len(a))
	for i := range a {
		ind[i] = i
	}
	sort.Slice(ind, func(i, j int) bool { return a[ind[i]] < a[ind[j]] })
	return ind
}

// Median ...
func (F32) Median(a []float32) float32 {
	var sorted []float32
	if sort.IsSorted(F32s(a)) {
		sorted = a
	} else {
		sorted = make([]float32, len(a))
		copy(sorted, a)
		sort.Slice(sorted, func(i, j int) bool { return sorted[i] < sorted[j] })
	}
	return sorted[int(len(sorted)/2)]
}

// Mean for []float32
func (F32) Mean(a []float32) float32 {
	return f32.Sum(a) / float32(len(a))
}

// Abs for []float32
func (F32) Abs(a float32) float32 {
	if a < float32(0) {
		return -a
	}
	return a
}

// MaxIdx ...
func (F32) MaxIdx(a []float32) int {
	mi := -1
	for i, v := range a {
		if mi < 0 || v > a[mi] {
			mi = i
		}
	}
	return mi
}

// MinIdx ...
func (F32) MinIdx(a []float32) int {
	mi := -1
	for i, v := range a {
		if mi < 0 || v < a[mi] {
			mi = i
		}
	}
	return mi
}

// Max ...
func (F32) Max(a []float32) float32 {
	mi := f32.MaxIdx(a)
	if mi < 0 {
		return math32.NaN()
	}
	return a[mi]
}

// Min ...
func (F32) Min(a []float32) float32 {
	mi := f32.MinIdx(a)
	if mi < 0 {
		return math32.NaN()
	}
	return a[mi]
}

// Alloc []float32
func (F32) Alloc(n int, ptrs ...*F32s) {
	c := n * len(ptrs)
	a := make(F32s, c)
	for i, ptr := range ptrs {
		*ptr = a[n*i : n*i+n]
	}
}

// EqualWithinAbs returns true if a and b have an absolute
// difference of less than tol.
func (F32) EqualWithinAbs(a, b, tol float32) bool {
	return a == b || math32.Abs(a-b) <= tol
}

// CheckFloat ...
func (F32) CheckFloat(msg string, ai float32) {
	if math32.IsInf(ai, -1) {
		panic(fmt.Errorf("-inf at %s", msg))

	}
	if math32.IsInf(ai, 1) {
		panic(fmt.Errorf("+inf at %s", msg))

	}
	if math32.IsNaN(ai) {
		panic(fmt.Errorf("nan at %s", msg))
	}

}

// Scale ...
func (F32) Scale(scale float32, a []float32) {
	for i := range a {
		a[i] *= scale
	}
}

// Add ...
func (F32) Add(dst, a []float32) {
	for i, v := range a {
		dst[i] += v
	}
}

// Mul ...
func (F32) Mul(dst, a []float32) {
	for i, v := range a {
		dst[i] *= v
	}
}

// Sign ...
func (F32) Sign(x float32) float32 {
	if math32.Signbit(x) {
		return -1
	}
	return 1
}

// Reduce ...
func (F32) Reduce(a []float32, f func(carry, item float32) float32, init float32) float32 {
	r := init
	for _, v := range a {
		r = f(r, v)
	}
	return r
}

// Square ...
func (F32) Square(x float32) float32 { return x * x }

// vanillaAddTo  for []float32
func (F32) vanillaAddTo(dst, a, b []float32) {
	for i := range dst {
		dst[i] = a[i] + b[i]
	}
}

// vanillaSubTo  for []float32
func (F32) vanillaSubTo(dst, a, b []float32) {
	for i := range dst {
		dst[i] = a[i] - b[i]
	}
}

// vanillaMulTo  for []float32
func (F32) vanillaMulTo(dst, a, b []float32) {
	for i := range dst {
		dst[i] = a[i] * b[i]
	}
}

// vanillaScaleTo  for []float32
func (F32) vanillaScaleTo(dst, a []float32, scale float32) {
	for i := range dst {
		dst[i] = a[i] * scale
	}
}

// vanillaSum for []float32
func (F32) vanillaSum(a []float32) float32 {
	acc := float32(0)
	for _, v := range a {
		acc += v
	}
	return acc
}

// vanillaDot for []float32
func (F32) vanillaDot(a, b []float32) float32 {
	acc := float32(0)
	for i, v := range a {
		acc += v * b[i]
	}
	return acc
}

type F64 float64
type F64s []float64

var f64 F64

func (F64) NaN() float64 { return math64.NaN() }

func (F64) IsNaN(x float64) bool { return math64.IsNaN(x) }

// Len (sort.Interface)
func (a F64s) Len() int { return len(a) }

// Less  (sort.Interface)
func (a F64s) Less(i, j int) bool { return a[i] < a[j] }

// Swap  (sort.Interface)
func (a F64s) Swap(i, j int) { a[i], a[j] = a[j], a[i] }

// Sort  (sort.Interface)
func (a F64s) Sort() {
	sort.Sort(F64s(a))
}

// Search  (sort.Interface)
func (a F64s) Search(x float64) int {
	return sort.Search(len(a), func(i int) bool { return a[i] >= x })
}

// ArgSort ...
func (F64) ArgSort(a []float64) []int {
	ind := make([]int, len(a))
	for i := range a {
		ind[i] = i
	}
	sort.Slice(ind, func(i, j int) bool { return a[ind[i]] < a[ind[j]] })
	return ind
}

// Median ...
func (F64) Median(a []float64) float64 {
	var sorted []float64
	if sort.IsSorted(F64s(a)) {
		sorted = a
	} else {
		sorted = make([]float64, len(a))
		copy(sorted, a)
		sort.Slice(sorted, func(i, j int) bool { return sorted[i] < sorted[j] })
	}
	return sorted[int(len(sorted)/2)]
}

// Mean for []float64
func (F64) Mean(a []float64) float64 {
	return f64.Sum(a) / float64(len(a))
}

// Abs for []float64
func (F64) Abs(a float64) float64 {
	if a < float64(0) {
		return -a
	}
	return a
}

// MaxIdx ...
func (F64) MaxIdx(a []float64) int {
	mi := -1
	for i, v := range a {
		if mi < 0 || v > a[mi] {
			mi = i
		}
	}
	return mi
}

// MinIdx ...
func (F64) MinIdx(a []float64) int {
	mi := -1
	for i, v := range a {
		if mi < 0 || v < a[mi] {
			mi = i
		}
	}
	return mi
}

// Max ...
func (F64) Max(a []float64) float64 {
	mi := f64.MaxIdx(a)
	if mi < 0 {
		return math64.NaN()
	}
	return a[mi]
}

// Min ...
func (F64) Min(a []float64) float64 {
	mi := f64.MinIdx(a)
	if mi < 0 {
		return math64.NaN()
	}
	return a[mi]
}

// Alloc []float64
func (F64) Alloc(n int, ptrs ...*F64s) {
	c := n * len(ptrs)
	a := make(F64s, c)
	for i, ptr := range ptrs {
		*ptr = a[n*i : n*i+n]
	}
}

// EqualWithinAbs returns true if a and b have an absolute
// difference of less than tol.
func (F64) EqualWithinAbs(a, b, tol float64) bool {
	return a == b || math64.Abs(a-b) <= tol
}

// CheckFloat ...
func (F64) CheckFloat(msg string, ai float64) {
	if math64.IsInf(ai, -1) {
		panic(fmt.Errorf("-inf at %s", msg))

	}
	if math64.IsInf(ai, 1) {
		panic(fmt.Errorf("+inf at %s", msg))

	}
	if math64.IsNaN(ai) {
		panic(fmt.Errorf("nan at %s", msg))
	}

}

// Scale ...
func (F64) Scale(scale float64, a []float64) {
	for i := range a {
		a[i] *= scale
	}
}

// Add ...
func (F64) Add(dst, a []float64) {
	for i, v := range a {
		dst[i] += v
	}
}

// Mul ...
func (F64) Mul(dst, a []float64) {
	for i, v := range a {
		dst[i] *= v
	}
}

// Sign ...
func (F64) Sign(x float64) float64 {
	if math64.Signbit(x) {
		return -1
	}
	return 1
}

// Reduce ...
func (F64) Reduce(a []float64, f func(carry, item float64) float64, init float64) float64 {
	r := init
	for _, v := range a {
		r = f(r, v)
	}
	return r
}

// Square ...
func (F64) Square(x float64) float64 { return x * x }

// vanillaAddTo  for []float64
func (F64) vanillaAddTo(dst, a, b []float64) {
	for i := range dst {
		dst[i] = a[i] + b[i]
	}
}

// vanillaSubTo  for []float64
func (F64) vanillaSubTo(dst, a, b []float64) {
	for i := range dst {
		dst[i] = a[i] - b[i]
	}
}

// vanillaMulTo  for []float64
func (F64) vanillaMulTo(dst, a, b []float64) {
	for i := range dst {
		dst[i] = a[i] * b[i]
	}
}

// vanillaScaleTo  for []float64
func (F64) vanillaScaleTo(dst, a []float64, scale float64) {
	for i := range dst {
		dst[i] = a[i] * scale
	}
}

// vanillaSum for []float64
func (F64) vanillaSum(a []float64) float64 {
	acc := float64(0)
	for _, v := range a {
		acc += v
	}
	return acc
}

// vanillaDot for []float64
func (F64) vanillaDot(a, b []float64) float64 {
	acc := float64(0)
	for i, v := range a {
		acc += v * b[i]
	}
	return acc
}
